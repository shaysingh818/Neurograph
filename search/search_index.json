{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Neurograph","text":"<p>Neurograph is a graph deep learning library. This library is still in the early phases of development and will evolve over time. This can be thought of as a toy project for combining concepts from graph theory and deep learning.</p>"},{"location":"#purpose","title":"Purpose","text":"<ul> <li>Experiment and research algorithms in graph theory and understand it's applications</li> <li>Tie concepts from graph theory to deep learning</li> <li>Data manipulation tool that utilize graph representations</li> <li>Invent a new graph neural network architecture</li> <li>Framework to visualize graphs</li> </ul>"},{"location":"#installation-and-setup","title":"Installation and Setup","text":"<pre><code>git clone https://github.com/shaysingh818/Neurograph.git\ncd src/\nsudo make install\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>   /* create dataframe from csv file */\n    frame_t *iris = dataframe(\"iris.csv\", 1024, 150, \",\"); \n    if(iris-&gt;status != true){\n        printf(\"Error creating frame\\n\"); \n    }\n\n    /* select cols to use */\n    array_t *selected_cols = init_array(); \n    insert_char(selected_cols, \"f1\"); \n    insert_char(selected_cols, \"f2\");\n    insert_char(selected_cols, \"f3\");\n    insert_char(selected_cols, \"f4\");\n\n    mat_t *inputs = frame_to_matrix(iris, selected_cols);  \n    value_t *input = value(inputs);\n\n    /* select output cols to use */\n    array_t *output_cols = init_array(); \n    insert_char(output_cols, \"f5\"); \n    mat_t *outputs = frame_to_matrix(iris, output_cols);  \n\n    /* create network */\n    double learning_rate = 0.01; \n    net_t *nn = init_network(learning_rate, input, 4); \n    layer(nn, linear(4, 5));\n    layer(nn, activation(4, 5, \"tanh\")); \n    layer(nn, linear(5, 1)); \n    layer(nn, activation(5, 1, \"tanh\"));\n    batch_train(nn, 10000, outputs, true);\n\n    /* batch inputs and outputs */\n    mat_t **x_train = batch_matrix(input-&gt;val, 4); \n    mat_t **y_train = batch_matrix(outputs, 4);\n\n    /* predict and get results*/\n    int row = 30;\n    mat_t *results = predict(nn, x_train[row]);     \n\n    printf(\"Expected\\n\"); \n    print_vec(y_train[row]); \n    printf(\"Actual\\n\"); \n    print_vec(results); \n</code></pre>"},{"location":"#design","title":"Design","text":"<pre><code>flowchart LR\n\n\nA[Python Library] --&gt; B[Core Library]\nB[Core Library] --&gt; C[Graph Theory]\nB[Core Library] --&gt; D[Deep Learning]\nB[Core Library] --&gt; F[Data Extraction]\nB[Core Library] --&gt; G[Data Structures]\n\nC[Graph Theory] --&gt; H[Graph Neural Network]\nD[Deep Learning] --&gt; H[Graph Neural Network]\n\nF[Data Extraction] --&gt; I[Data Manipulation]\nG[Data Structures] --&gt; I[Data Manipulation]\n</code></pre>"},{"location":"#common-use-cases","title":"Common Use Cases","text":"<ul> <li>Require the ability to represent datasets as graphs to understand the relationships between features</li> <li>Expirmenting with graph algorithms for creating neural network architectures</li> </ul>"},{"location":"contribute/","title":"Contribute","text":"<p>If anyone is interested in contributing to neurograph, there are plenty of issues on the github repository that anyone is free to tackle. If more context is needed for an issue, either leave a comment on github, or reach out directly to shalinsingh818@gmail.com. If there are enough contributors, a discord server will be created.</p>"},{"location":"contribute/#guidelines","title":"Guidelines","text":"<ul> <li>Each PR must run through the github actions CI/CD pipleine</li> <li>All Unit tests for the core library must pass</li> <li>Document changes on backstage site (if needed)</li> <li>Write Unit tests for you're proposed changes</li> <li>Try your best to follow the structure layed out in the packages</li> </ul>"},{"location":"python/","title":"Python Library","text":"<p>Neurograph was originally going to have python support in the public release. After finishing the first initial version of the core library in C, it was decided that far more improvements need to be made to the C library before creating a usable python wrapper around it. </p>"},{"location":"python/#why-its-not-support-yet","title":"Why It's Not Support Yet","text":"<ul> <li>Memory Corruption Issues with Cython and C Library</li> <li>C Library still needs more performance tuning</li> <li>Core library hasn't been used for any serious modeling yet</li> <li>Not enough features/algorithms shipped</li> </ul>"},{"location":"python/#current-state","title":"Current State","text":"<p>While Python support is not publicly available, there was work done for laying out the shell of how cython would interact with the C library. Sample of the wrapper files can be found here. When running the <code>main.py</code> file, you'll notice some memory corruption or double free issues.  </p>"},{"location":"core-library/computation-graph/","title":"Computation Graph","text":"<ul> <li>Graph structure used for finding gradients for each operation</li> <li>Depends on generic value (Tensors in future versions)</li> </ul>"},{"location":"core-library/computation-graph/#computation-graph","title":"Computation Graph","text":"<pre><code>struct ComputationGraph {\n    int size, curr_index;  \n    mat_t *inputs, *output_error; \n    value_t **nodes; \n}; \n\ntypedef struct ComputationGraph computation_graph_t;\n</code></pre>"},{"location":"core-library/computation-graph/#create_graph","title":"create_graph","text":"<pre><code>computation_graph_t *create_graph(); \n</code></pre>"},{"location":"core-library/computation-graph/#append_op","title":"append_op","text":"Parameter Name Type Description graph <code>computation_graph</code> Instance of computation graph val <code>value_t</code> Instance of generic value <pre><code>void append_op(computation_graph_t *graph, value_t *val);\n</code></pre>"},{"location":"core-library/computation-graph/#append_op_1","title":"append_op","text":"Parameter Name Type Description graph <code>computation_graph</code> Instance of computation graph <pre><code>void forward_nodes(computation_graph_t *graph); \n</code></pre>"},{"location":"core-library/computation-graph/#append_op_2","title":"append_op","text":"Parameter Name Type Description graph <code>computation_graph</code> Instance of computation graph output_error <code>mat_t</code> Matrix instance of the output error from operation <pre><code>void backward_nodes(computation_graph_t *graph, mat_t *output_error); \n</code></pre>"},{"location":"core-library/core-library/","title":"Core library","text":""},{"location":"core-library/core-library/#data-structures","title":"Data Structures","text":"<p>The data structures library is a suite of data structures needed for creating dataframes, representing graphs and performing matrix operations. Currently the data structures support performing operations on the <code>node_t</code> structure. Eventually it will support generic types using void pointers. </p>"},{"location":"core-library/core-library/#queue","title":"Queue","text":"<pre><code>struct Queue {\n    unsigned capacity; \n    int front_index, rear_index, item_count;\n    node_t* front, rear; \n    node_t **items; \n}; \n\ntypedef struct Queue queue_t;\n</code></pre>"},{"location":"core-library/core-library/#init_queue","title":"init_queue","text":"Parameter Name Type Description capacity <code>unsigned</code> Capacity that queue can hold <pre><code>queue_t init_queue(unsigned *capacity); \n</code></pre>"},{"location":"core-library/core-library/#is_full","title":"is_full","text":"Parameter Name Type Description queue <code>queue_t</code> Instance of queue pointer <pre><code>int is_full(queue_t *queue); \n</code></pre>"},{"location":"core-library/core-library/#is_empty","title":"is_empty","text":"Parameter Name Type Description queue <code>queue_t</code> Instance of queue pointer <pre><code>int is_empty(queue_t *queue); \n</code></pre>"},{"location":"core-library/core-library/#front","title":"front","text":"Parameter Name Type Description queue <code>queue_t</code> Instance of queue pointer <pre><code>int front(queue_t *queue); \n</code></pre>"},{"location":"core-library/core-library/#rear","title":"rear","text":"Parameter Name Type Description queue <code>queue_t</code> Instance of queue pointer <pre><code>int rear(queue_t *queue); \n</code></pre>"},{"location":"core-library/core-library/#push","title":"push","text":"Parameter Name Type Description queue <code>queue_t</code> Instance of queue pointer item <code>node_t</code> Instance of node pointer <pre><code>void push(queue_t *queue, node_t *item); \n</code></pre>"},{"location":"core-library/core-library/#pop","title":"pop","text":"Parameter Name Type Description queue <code>queue_t</code> Instance of queue pointer <pre><code>void pop(queue_t *queue); \n</code></pre>"},{"location":"core-library/core-library/#print_queue","title":"print_queue","text":"Parameter Name Type Description queue <code>queue_t</code> Instance of queue pointer <pre><code>void print_queue(queue_t *queue); \n</code></pre>"},{"location":"core-library/core-library/#extractors","title":"Extractors","text":""},{"location":"core-library/core-library/#computation-graph","title":"Computation Graph","text":""},{"location":"core-library/core-library/#graph-library","title":"Graph Library","text":""},{"location":"core-library/core-library/#deep-learning","title":"Deep Learning","text":""},{"location":"core-library/extractors/","title":"Extractors","text":""},{"location":"core-library/extractors/#frame","title":"Frame","text":"<pre><code>struct Frame {\n    int buffer_size, header_count; \n    int curr_row, row_count, row_limit; \n    char *filename, *file_buffer, *delimiter; \n    bool status;\n    mat_t *matrix;    \n    array_t *headers; \n    hash_table_t *frame;\n};\n\ntypedef struct Frame frame_t; \n</code></pre>"},{"location":"core-library/extractors/#create_frame","title":"create_frame","text":"Parameter Name Type Description filepath <code>char*</code> path to csv file buffer_size <code>int</code> max buffer size for each file line row_limit <code>int</code> Amount of rows to load delimiter <code>char*</code> Delimiter to separate <pre><code>frame_t *create_frame(char *filepath, int buffer_size, int row_limit, char *delimiter);\n</code></pre>"},{"location":"core-library/extractors/#dataframe","title":"dataframe","text":"Parameter Name Type Description filepath <code>char*</code> path to csv file buffer_size <code>int</code> max buffer size for each file line row_limit <code>int</code> Amount of rows to load delimiter <code>char*</code> Delimiter to separate <pre><code>frame_t *dataframe(char *filepath, int buffer_size, int row_limit, char *delimiter);  \n</code></pre>"},{"location":"core-library/extractors/#init_row_value","title":"init_row_value","text":"Parameter Name Type Description index <code>int</code> row index value <code>char*</code> row value <pre><code>row_value_t *init_row_value(int index, char *value); \n</code></pre>"},{"location":"core-library/extractors/#frame_to_matrix","title":"frame_to_matrix","text":"Parameter Name Type Description frame <code>frame_t</code> Instance of data frame cols <code>array_t</code> Array with column values stored <pre><code>mat_t *frame_to_matrix(frame_t *frame, array_t *cols); \n</code></pre>"},{"location":"core-library/extractors/#extract_headers","title":"extract_headers","text":"Parameter Name Type Description frame <code>frame_t</code> Instance of data frame <pre><code>void extract_headers(frame_t *frame);\n</code></pre>"},{"location":"core-library/extractors/#init_rows","title":"init_rows","text":"Parameter Name Type Description frame <code>frame_t</code> Instance of data frame <pre><code>void init_rows(frame_t *frame); \n</code></pre>"},{"location":"core-library/extractors/#print_cols","title":"print_cols","text":"Parameter Name Type Description frame <code>frame_t</code> Instance of data frame <pre><code>void print_cols(frame_t *frame); \n</code></pre>"},{"location":"core-library/extractors/#print_rows","title":"print_rows","text":"Parameter Name Type Description frame <code>frame_t</code> Instance of data frame <pre><code>void print_rows(frame_t *frame);\n</code></pre>"},{"location":"core-library/extractors/#select_cols","title":"select_cols","text":"Parameter Name Type Description frame <code>frame_t</code> Instance of data frame headers <code>void**</code> Headers to select from frame <pre><code>void select_cols(frame_t *frame, void** headers); \n</code></pre>"},{"location":"core-library/extractors/#drop_cols","title":"drop_cols","text":"Parameter Name Type Description frame <code>frame_t</code> Instance of data frame cols <code>array_t</code> Columns to drop from frame <pre><code>void drop_cols(frame_t *frame, array_t *cols); \n</code></pre>"},{"location":"core-library/extractors/#get_row_key","title":"get_row_key","text":"Parameter Name Type Description frame <code>frame_t</code> Instance of data frame key <code>char*</code> Row key to search for <pre><code>char **get_row_key(frame_t *frame, char *key); \n</code></pre>"},{"location":"core-library/extractors/#add_frame_cols","title":"add_frame_cols","text":"Parameter Name Type Description frame <code>frame_t</code> Instance of data frame col1 <code>char*</code> Column on dataframe col2 <code>char*</code> Column on dataframe result_col <code>char*</code> Name of result column key <pre><code>void add_frame_cols(frame_t *frame, char *col1, char *col2, char *result_col); \n</code></pre>"},{"location":"core-library/extractors/#subtract_frame_cols","title":"subtract_frame_cols","text":"Parameter Name Type Description frame <code>frame_t</code> Instance of data frame col1 <code>char*</code> Column on dataframe col2 <code>char*</code> Column on dataframe result_col <code>char*</code> Name of result column key <pre><code>void subtract_frame_cols(frame_t *frame, char *col1, char *col2, char *result_col); \n</code></pre>"},{"location":"core-library/networks/","title":"Networks","text":"<ul> <li>Module for creating neural networks</li> <li>Contains helpers for creating layers </li> <li>Built on the computation graph library for automatic differentiation</li> </ul>"},{"location":"core-library/networks/#network","title":"Network","text":"<pre><code>struct Network {\n    int num_layers, layer_count, batch_size;\n    int front_index, rear_index, pass_index;  \n    double learning_rate, loss;\n    bool batched; \n    mat_t **input_batches;  \n    value_t *input; \n    layer_t **layers; \n    computation_graph_t *graph; \n}; \n\ntypedef struct Network net_t; \n</code></pre>"},{"location":"core-library/data-structures/list/","title":"List","text":""},{"location":"core-library/data-structures/list/#adjacency-list","title":"Adjacency List","text":"<p>The list data structure package contains structures for adjacency lists, arrays and linked lists. The adjacency lists are needed for representing graphs. Arrays are used for general memory usage. Linked lists are not used so much but are convienient to have in the long term.</p> <pre><code>struct AdjacencyList {\n    int v;\n    int e;  \n    int *visited, *used;\n    bool directed;\n    bool err;   \n    edge_t **edges;\n    node_list_t **items;    \n}; \n\ntypedef struct AdjacencyList adj_list_t; \n</code></pre>"},{"location":"core-library/data-structures/list/#init_adj_list","title":"init_adj_list","text":"Parameter Name Type Description v <code>int</code> Vertices e <code>int</code> Edges directed <code>bool</code> Directed graph <pre><code>adj_list_t *init_adj_list(int v, int e, bool directed);\n</code></pre>"},{"location":"core-library/data-structures/list/#transpose_items","title":"transpose_items","text":"Parameter Name Type Description g <code>adj_list_t</code> Graph to be transposed r <code>adj_list _t</code> Reversed Result <pre><code>adj_list_t *transpose_items(adj_list_t *g, adj_list_t *r); \n</code></pre>"},{"location":"core-library/data-structures/list/#add_node","title":"add_node","text":"Parameter Name Type Description g <code>adj_list_t</code> Graph to add node to src_id <code>int</code> ID of source node src_label <code>char*</code> Character result of source node dest_id <code>int</code> Destination node id dest_label <code>char*</code> Destination node label weight <code>int</code> Weight of relationship <pre><code>int add_node(\n    adj_list_t *g, int src_id, char *src_label, \n    int dest_id, char *dest_label, int weight\n); \n</code></pre>"},{"location":"core-library/data-structures/list/#add_end_node","title":"add_end_node","text":"Parameter Name Type Description g <code>adj_list_t</code> Graph to add end node to src_id <code>int</code> ID of source node src_label <code>char*</code> Character result of source node weight <code>int</code> Weight of relationship <pre><code>int add_end_node(adj_list_t *g, int src_id, char *src_label, int weight);\n</code></pre>"},{"location":"core-library/data-structures/list/#get_node_by_id","title":"get_node_by_id","text":"Parameter Name Type Description g <code>adj_list_t</code> Graph to add end node to id <code>int</code> ID of node to search <pre><code>node_t *get_node_by_id(adj_list_t *g, int id);\n</code></pre>"},{"location":"core-library/data-structures/list/#resize_adj_list","title":"resize_adj_list","text":"Parameter Name Type Description g <code>adj_list_t</code> Graph to resize id <code>int</code> New vertice size <pre><code>void resize_adj_list(adj_list_t *g, int new_size);  \n</code></pre>"},{"location":"core-library/data-structures/list/#array","title":"Array","text":"<pre><code>struct Array {\n    int capacity, used, front_index, rear_index, item_count; \n    int *insert_counts;  \n    node_t **items; \n};\ntypedef struct Array array_t; \n</code></pre>"},{"location":"core-library/data-structures/list/#init_array","title":"init_array","text":"<pre><code>array_t *init_array(); \n</code></pre>"},{"location":"core-library/data-structures/list/#insert","title":"insert","text":"Parameter Name Type Description a <code>array_t</code> Array to add item to item <code>node_t</code> Item to add to array <pre><code>void insert(array_t *a, node_t *item);\n</code></pre>"},{"location":"core-library/data-structures/list/#insert_char","title":"insert_char","text":"Parameter Name Type Description a <code>array_t</code> Array to add string to item <code>char*</code> Character string to add to array <pre><code>void insert_char(array_t *a, char *item);\n</code></pre>"},{"location":"core-library/data-structures/list/#remove_char","title":"remove_char","text":"Parameter Name Type Description a <code>array_t</code> Array to remove char from item <code>char*</code> Character string to add to array <pre><code>void remove_char(array_t *a, char *item);\n</code></pre>"},{"location":"core-library/data-structures/list/#pop_array","title":"pop_array","text":"Parameter Name Type Description a <code>array_t</code> Array to pop item from <pre><code>void pop_array(array_t *a);\n</code></pre>"},{"location":"core-library/data-structures/list/#print_array","title":"print_array","text":"Parameter Name Type Description a <code>array_t</code> Array to print <pre><code>void print_array(array_t *a);\n</code></pre>"},{"location":"core-library/data-structures/map/","title":"Map","text":""},{"location":"core-library/data-structures/map/#hash-table","title":"Hash Table","text":""},{"location":"core-library/data-structures/map/#hash_table","title":"hash_table","text":"Parameter Name Type Description table <code>hash_table_t</code> Hash Table instance load_factor <code>double</code> Load factor for probing key_cmp <code>compare_func</code> Key comparison function key_destructor <code>destructor_func</code> function to deallocate key val_destructor <code>destructor_func</code> function to deallocate value hash_function <code>hash_func</code> Hash function to create hash key <pre><code>hash_table_t *hash_table(\n    int size, \n    double load_factor,\n    compare_func key_cmp, \n    destructor_func key_destructor,\n    destructor_func val_destructor,\n    hash_func hash_function\n); \n</code></pre>"},{"location":"core-library/data-structures/map/#delete_hash_table","title":"delete_hash_table","text":"Parameter Name Type Description table <code>hash_table_t</code> Hash Table instance <pre><code>void delete_hash_table(hash_table_t *table);\n</code></pre>"},{"location":"core-library/data-structures/map/#add_table_map","title":"add_table_map","text":"Parameter Name Type Description table <code>hash_table_t</code> Hash Table instance key <code>void</code> Key to map to value value <code>void</code> Value to map from key <pre><code>void add_table_map(hash_table_t *table, void *key, void *value); \n</code></pre>"},{"location":"core-library/data-structures/map/#delete_table_key","title":"delete_table_key","text":"Parameter Name Type Description table <code>hash_table_t</code> Hash Table instance key <code>void</code> Key to delete <pre><code>void delete_table_key(hash_table_t *table, void *key); \n</code></pre>"},{"location":"core-library/data-structures/map/#lookup_table_key","title":"lookup_table_key","text":"Parameter Name Type Description table <code>hash_table_t</code> Hash Table instance key <code>void</code> Key to delete <pre><code>void *lookup_table_key(hash_table_t *table, void *key); \n</code></pre>"},{"location":"core-library/data-structures/map/#table_resize","title":"table_resize","text":"parameter name type description table <code>hash_table_t</code> hash table instance new_size <code>int</code> new size to allocate <pre><code>void table_resize(hash_table_t *table, int new_size); \n</code></pre>"},{"location":"core-library/data-structures/map/#probe","title":"probe","text":"parameter name type description k <code>int</code> hash table instance i <code>int</code> new size to allocate m <code>int</code> new size to allocate <pre><code>int probe(int k, int i, int m);\n</code></pre>"},{"location":"core-library/data-structures/map/#print_table","title":"print_table","text":"parameter name type description table <code>hash_table_t</code> hash table instance <pre><code>void print_table(hash_table_t *table); \n</code></pre>"},{"location":"core-library/data-structures/map/#map","title":"Map","text":"<pre><code>struct hash_linked_list {\n    int hash_key;\n    void *key;\n    void *value;  \n    struct hash_linked_list *next; \n}; \n\ntypedef struct hash_linked_list h_ll_t; \n\n\nstruct HashTable {\n    h_ll_t **table;  \n    int size, used, active; \n    compare_func key_cmp; \n    destructor_func key_destructor;\n    destructor_func val_destructor;  \n    hash_func hash_function; \n}; \n\ntypedef struct HashTable map_t;\n</code></pre>"},{"location":"core-library/data-structures/map/#init_table","title":"init_table","text":"Parameter Name Type Description size <code>int</code> size of table key_cmp <code>compare_func</code> Key comparision function key_destructor <code>destructor_func</code> function to deallocate key val_destructor <code>destructor_func</code> function to deallocate value hash_function <code>hash_func</code> function to hash key <pre><code>map_t *init_table(\n    int size, \n    compare_func key_cmp, \n    destructor_func key_destructor, \n    destructor_func val_destructor,\n    hash_func hash_function\n);\n</code></pre>"},{"location":"core-library/data-structures/map/#delete_table","title":"delete_table","text":"Parameter Name Type Description table <code>map_t</code> table instance <pre><code>void delete_table(map_t *table); \n</code></pre>"},{"location":"core-library/data-structures/map/#lookup_key","title":"lookup_key","text":"Parameter Name Type Description table <code>map_t</code> table instance key <code>void</code> void key pointer <pre><code>void *lookup_key(map_t *table, void *key); \n</code></pre>"},{"location":"core-library/data-structures/map/#insert_key","title":"insert_key","text":"Parameter Name Type Description table <code>map_t</code> table instance key <code>void</code> void key pointer <pre><code>void *insert_key(map_t *table, void *key); \n</code></pre>"},{"location":"core-library/data-structures/map/#delete_key","title":"delete_key","text":"Parameter Name Type Description table <code>map_t</code> table instance key <code>void</code> void key pointer <pre><code>void *delete_key(map_t *table, void *key); \n</code></pre>"},{"location":"core-library/data-structures/map/#add_map","title":"add_map","text":"Parameter Name Type Description table <code>map_t</code> table instance key <code>void</code> void key pointer value <code>void</code> void value pointer <pre><code>void add_map(map_t *table, void *key, void *value); \n</code></pre>"},{"location":"core-library/data-structures/map/#resize","title":"resize","text":"Parameter Name Type Description table <code>map_t</code> table instance new_size <code>int</code> new size of table <pre><code>void resize(map_t *table, int new_size);  \n</code></pre>"},{"location":"core-library/data-structures/map/#contains_key","title":"contains_key","text":"Parameter Name Type Description table <code>map_t</code> table instance key <code>void</code> void key pointer <pre><code>bool contains_key(map_t *table, void* key); \n</code></pre>"},{"location":"core-library/data-structures/map/#new_hash_ll","title":"new_hash_ll","text":"<pre><code>h_ll_t *new_hash_ll();\n</code></pre>"},{"location":"core-library/data-structures/map/#get_prev_link","title":"get_prev_link","text":"Parameter Name Type Description list <code>h_ll_t</code> Hash Linked List instance hash_key <code>int</code> Numeric Hash Key key <code>void</code> Key Value key_cmp <code>compare_func</code> Function to compare key <pre><code>h_ll_t *get_prev_link(h_ll_t *list, int hash_key, void *key, compare_func key_cmp);\n</code></pre>"},{"location":"core-library/data-structures/map/#lookup_key_list","title":"lookup_key_list","text":"Parameter Name Type Description list <code>h_ll_t</code> Hash Linked List instance hash_key <code>int</code> Numeric Hash Key key <code>void</code> Key Value key_cmp <code>compare_func</code> Function to compare key <pre><code>h_ll_t *lookup_key_list(h_ll_t *list, int hash_key, void *key, compare_func key_cmp);  \n</code></pre>"},{"location":"core-library/data-structures/map/#contains_key_list","title":"contains_key_list","text":"Parameter Name Type Description list <code>h_ll_t</code> Hash Linked List instance hash_key <code>int</code> Numeric Hash Key key <code>void</code> Key Value key_cmp <code>compare_func</code> Function to compare key <pre><code>bool contains_key_list(h_ll_t *list, int hash_key, void *key, compare_func key_cmp); \n</code></pre>"},{"location":"core-library/data-structures/map/#delete_key_list","title":"delete_key_list","text":"Parameter Name Type Description list <code>h_ll_t</code> Hash Linked List instance hash_key <code>int</code> Numeric Hash Key key <code>void</code> Key Value key_cmp <code>compare_func</code> Function to compare key key_destructor <code>destructor_func</code> function to deallocate key val_destructor <code>destructor_func</code> function to deallocate value <pre><code>bool delete_key_list(\n    h_ll_t *list, \n    int hash_key, \n    void *key, \n    compare_func key_cmp, \n    destructor_func key_destructor, \n    destructor_func val_destructor\n); \n</code></pre>"},{"location":"core-library/data-structures/map/#add_map_list","title":"add_map_list","text":"Parameter Name Type Description list <code>h_ll_t</code> Hash Linked List instance hash_key <code>int</code> Numeric Hash Key key <code>void</code> Key Value value <code>void</code> Key application value <pre><code>void add_map_list(h_ll_t *list, int hash_key, void *key, void *value);\n</code></pre>"},{"location":"core-library/data-structures/map/#insert_key_list","title":"insert_key_list","text":"Parameter Name Type Description list <code>h_ll_t</code> Hash Linked List instance hash_key <code>int</code> Numeric Hash Key key <code>void</code> Key Value key_cmp <code>compare_func</code> Function to compare key <pre><code>void insert_key_list(h_ll_t *list, int hash_key, void *key, compare_func key_cmp); \n</code></pre>"},{"location":"core-library/data-structures/map/#delete_hash_ll","title":"delete_hash_ll","text":"Parameter Name Type Description list <code>h_ll_t</code> Hash Linked List instance hash_key <code>int</code> Numeric Hash Key key_destructor <code>destructor_func</code> function to deallocate key val_destructor <code>destructor_func</code> function to deallocate value free_resources <code>bool</code> Toggle freeing map resources <pre><code>void delete_hash_ll(\n    h_ll_t *list, \n    destructor_func key_destructor, \n    destructor_func val_destructor, \n    bool free_resources\n);\n</code></pre>"},{"location":"core-library/data-structures/matrix/","title":"Matrix","text":""},{"location":"core-library/data-structures/matrix/#matrix","title":"Matrix","text":"<pre><code>struct Matrix {\n    int rows; \n    int cols; \n    double **arr; \n}; \n\ntypedef struct Matrix mat_t; \n</code></pre>"},{"location":"core-library/data-structures/matrix/#init_vec","title":"init_vec","text":"Parameter Name Type Description rows <code>int</code> rows of matrix cols <code>double</code> cols of matrix identity <code>bool</code> Load identity of matrix <pre><code>mat_t *init_vec(int rows, int cols, bool identity);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#init_matrix","title":"init_matrix","text":"Parameter Name Type Description rows <code>int</code> rows of matrix cols <code>double</code> cols of matrix <pre><code>mat_t *init_matrix(int rows, int cols);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#apply","title":"apply","text":"Parameter Name Type Description activation_function <code>double(*activation_function)(double)</code> function to apply to matrix m <code>mat_t</code> matrix instance <pre><code>mat_t *apply(double(*activation_function)(double), mat_t *m);  \n</code></pre>"},{"location":"core-library/data-structures/matrix/#copy_matrix","title":"copy_matrix","text":"Parameter Name Type Description m <code>mat_t</code> matrix instance <pre><code>mat_t *copy_matrix(mat_t *m);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#load_matrix","title":"load_matrix","text":"Parameter Name Type Description filename <code>char*</code> Name of file to load matrix from <pre><code>mat_t *load_matrix(char *filename);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#to_rows","title":"to_rows","text":"Parameter Name Type Description m <code>mat_t</code> matrix instance <pre><code>mat_t **to_rows(mat_t *m);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#to_cols","title":"to_cols","text":"Parameter Name Type Description m <code>mat_t</code> matrix instance <pre><code>mat_t **to_cols(mat_t *m);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#batch_rows","title":"batch_rows","text":"Parameter Name Type Description m <code>mat_t</code> matrix instance limit <code>int</code> amount to batch the matrix rows by <pre><code>mat_t **batch_rows(mat_t *m, int limit);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#batch_matrix","title":"batch_matrix","text":"Parameter Name Type Description m <code>mat_t</code> matrix instance batch_size <code>int</code> amount to batch the matrix rows by <pre><code>mat_t **batch_matrix(mat_t *m, int batch_size); \n</code></pre>"},{"location":"core-library/data-structures/matrix/#copy_arr_to_matrix","title":"copy_arr_to_matrix","text":"Parameter Name Type Description m <code>int</code> rows n <code>int</code> cols arr <code>double[m][n]</code> 2d array in C <pre><code>mat_t *copy_arr_to_matrix(int m, int n, double arr[m][n]); \n</code></pre>"},{"location":"core-library/data-structures/matrix/#compare_matrix","title":"compare_matrix","text":"Parameter Name Type Description m <code>mat_t</code> first matrix to compare n <code>mat_t</code> second matrix to compare <pre><code>bool compare_matrix(mat_t *m, mat_t *n); \n</code></pre>"},{"location":"core-library/data-structures/matrix/#uniform_distribution","title":"uniform_distribution","text":"Parameter Name Type Description low <code>double</code> lower bound high <code>double</code> upper bound <pre><code>double uniform_distribution(double low, double high);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#get","title":"get","text":"Parameter Name Type Description m <code>mat_t</code> matrix instance row <code>int</code> row value index col <code>int</code> col value index <pre><code>double get(mat_t *m, int row, int col); \n</code></pre>"},{"location":"core-library/data-structures/matrix/#copy_arr_to_matrix_1","title":"copy_arr_to_matrix","text":"Parameter Name Type Description v1 <code>mat_t</code> first matrix to copy v2 <code>mat_t</code> second matrix to copy <pre><code>void copy_mat(mat_t *v1, mat_t *v2);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#print_vec","title":"print_vec","text":"Parameter Name Type Description v1 <code>mat_t</code> matrix instance to print <pre><code>void print_vec(mat_t *v1);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#matrix_free","title":"matrix_free","text":"Parameter Name Type Description m <code>mat_t</code> matrix instance to free <pre><code>void matrix_free(mat_t *m);  \n</code></pre>"},{"location":"core-library/data-structures/matrix/#randomize","title":"randomize","text":"Parameter Name Type Description m <code>mat_t</code> matrix instance to free n <code>int</code> bounded value <pre><code>void randomize(mat_t *mat, int n); \n</code></pre>"},{"location":"core-library/data-structures/matrix/#print_matrix","title":"print_matrix","text":"Parameter Name Type Description m <code>mat_t</code> matrix instance to free <pre><code>void print_matrix(mat_t *mat);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#fill_matrix","title":"fill_matrix","text":"Parameter Name Type Description m <code>mat_t</code> matrix instance to free n <code>int</code> values to fill matrix with <pre><code>void fill_mat(mat_t *m, int n); \n</code></pre>"},{"location":"core-library/data-structures/matrix/#save_matrix","title":"save_matrix","text":"Parameter Name Type Description m <code>mat_t</code> matrix instance to free filename <code>char</code> name of file to save matrix to <pre><code>void save_matrix(mat_t *m, char *filename);   \n</code></pre>"},{"location":"core-library/data-structures/matrix/#copy_matrix_values","title":"copy_matrix_values","text":"Parameter Name Type Description m <code>mat_t</code> first matrix instance m <code>mat_t</code> second matrix instance <pre><code>void copy_matrix_values(mat_t *m, mat_t *n);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#entry","title":"entry","text":"Parameter Name Type Description m <code>mat_t</code> first matrix instance row <code>int</code> row index col <code>int</code> col index value <code>double</code> value to insert <pre><code>void entry(mat_t *m, int row, int col, double value); \n</code></pre>"},{"location":"core-library/data-structures/matrix/#scalar_multiply","title":"scalar_multiply","text":"Parameter Name Type Description v1 <code>mat_t</code> matrix instance value <code>double</code> value to multiply by <pre><code>mat_t *scalar_multiply(mat_t *v1, double value);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#power","title":"power","text":"Parameter Name Type Description v1 <code>mat_t</code> matrix instance power <code>int</code> value to multiply by <pre><code>mat_t *scalar_multiply(mat_t *v1, double value);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#dot","title":"dot","text":"Parameter Name Type Description n <code>mat_t</code> matrix instance to dot product by m <code>mat_t</code> second matrix instance to dot product by <pre><code>mat_t *dot(mat_t *n, mat_t *m);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#multiply","title":"multiply","text":"Parameter Name Type Description v1 <code>mat_t</code> matrix instance to multiply by v2 <code>mat_t</code> second matrix instance to multiply by <pre><code>mat_t *multiply(mat_t *v1, mat_t *v2);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#elementwise_multiply","title":"elementwise_multiply","text":"Parameter Name Type Description v1 <code>mat_t</code> matrix instance to multiply by v2 <code>mat_t</code> second matrix instance to multiply by <pre><code>mat_t *elementwise_multiply(mat_t *v1, mat_t *v2); \n</code></pre>"},{"location":"core-library/data-structures/matrix/#add","title":"add","text":"Parameter Name Type Description n <code>mat_t</code> matrix instance m <code>mat_t</code> second matrix instance <pre><code>mat_t *add(mat_t *n, mat_t *m);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#scale","title":"scale","text":"Parameter Name Type Description v <code>mat_t</code> matrix instance value <code>double</code> value to scale by <pre><code>mat_t *scale(mat_t *v, double value); \n</code></pre>"},{"location":"core-library/data-structures/matrix/#scale_add","title":"scale_add","text":"Parameter Name Type Description n <code>mat_t</code> matrix instance m <code>mat_t</code> second matrix instance <pre><code>mat_t *scale_add(mat_t *n, mat_t *m);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#transpose","title":"transpose","text":"Parameter Name Type Description n <code>mat_t</code> matrix instance <pre><code>mat_t *transpose(mat_t *n);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#difference","title":"difference","text":"Parameter Name Type Description x <code>mat_t</code> matrix instance y <code>mat_t</code> second matrix instance <pre><code>mat_t *difference(mat_t *x, mat_t *y);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#vectorize","title":"vectorize","text":"Parameter Name Type Description input <code>mat_t</code> matrix instance <pre><code>mat_t *vectorize(mat_t *input); \n</code></pre>"},{"location":"core-library/data-structures/matrix/#im2col","title":"im2col","text":"Parameter Name Type Description input <code>mat_t</code> matrix instance feature_map <code>mat_t</code> matrix instance of feature map <pre><code>mat_t *im2col(mat_t *input, mat_t *feature_map); \n</code></pre>"},{"location":"core-library/data-structures/matrix/#adjacencymatrix","title":"AdjacencyMatrix","text":"<pre><code>struct AdjacencyMatrix {\n    int v;\n    int e;  \n    int *visited, *used;\n    bool directed;\n    bool err;   \n    mat_t *weights; \n    node_t **items;     \n}; \n\ntypedef struct AdjacencyMatrix adj_mat_t;\n</code></pre>"},{"location":"core-library/data-structures/matrix/#init_adj_mat","title":"init_adj_mat","text":"Parameter Name Type Description v <code>int</code> vertices e <code>int</code> edges directed <code>bool</code> toggle if graph is directed <pre><code>adj_mat_t *init_adj_mat(int v, int e, bool directed);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#add_node_mat","title":"add_node_mat","text":"Parameter Name Type Description m <code>adj_mat_t</code> adjacency matrix instance src_id <code>int</code> source node id src <code>char*</code> character value for source node dst_id <code>int</code> destination node id dst <code>char*</code> character value for destination node weight <code>double</code> weight value for node relationship <pre><code>void add_node_mat(\n    adj_mat_t *m, int src_id, char *src, \n    int dst_id, char *dst, double weight\n);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#tranpose_items_mat","title":"tranpose_items_mat","text":"Parameter Name Type Description m <code>adj_mat_t</code> adjacency matrix instance r <code>adj_mat_t</code> second adjacency matrix instance <pre><code>adj_mat_t *transpose_items_mat(adj_mat_t *m, adj_mat_t *r); \n</code></pre>"},{"location":"core-library/data-structures/matrix/#search_node_by_id_mat","title":"search_node_by_id_mat","text":"Parameter Name Type Description m <code>adj_mat_t</code> adjacency matrix instance id <code>int</code> id of node to search <pre><code>node_t *search_node_by_id_mat(adj_mat_t *m, int id);\n</code></pre>"},{"location":"core-library/data-structures/matrix/#print_adj_mat","title":"print_adj_mat","text":"Parameter Name Type Description m <code>adj_mat_t</code> adjacency matrix instance <pre><code>void print_adj_mat(adj_mat_t *m); \n</code></pre>"},{"location":"core-library/data-structures/ndarray/","title":"NDArray","text":"<p>NDArray is used for representing data in multiple dimensions. The NDArray structure allows you to set the rank, dimensions and values stored in memory. The values are  stored as a contigious array. Strides are used to perform indexing in 2 or more dimensions. </p>"},{"location":"core-library/data-structures/ndarray/#array-utilities","title":"Array Utilities","text":"Method Description <code>ndarray(int rank, int *shape)</code> Creates instance of ndarray data structure <code>reshape(ndarray_t *t, int rank, int *shape)</code> Reshape ndarray with new rank and shape dimensions <code>int nindex(ndarray_t *t, int *indices)</code> Gets one dimensional index value from array of indices <code>int *indices(ndarray_t *t, int index)</code> Get's indices associated with contigous index value <code>double nidx(ndarray_t *t, int *indices)</code> Get's value associated with indices <code>void nset(ndarray_t *t, int *indices, double value)</code> Set value at specific permutation of indices <code>void save_ndarray(ndarray_t *t, char *filename)</code> Save NDArray values to file in memory <code>ndarray_t *load_ndarray(char *filename)</code> Load NDArray values from saved file"},{"location":"core-library/data-structures/ndarray/#ndarrayrank-shape","title":"<code>ndarray(rank, shape)</code>","text":"<ul> <li>Parameters<ul> <li><code>rank</code>: Integer value that represents amount of dimensions in value. Eg. 2d, 3d Arrays</li> <li><code>shape</code> : Array of integers that correspond to the dimensions of the value. Example values: <code>(2, 3), (6, 6)</code>. </li> </ul> </li> </ul> <p>Notes: This method creates the NDArray using the <code>ndarray_t</code> structure from the core library. This does not work from C -&gt; python (backwards compatible)</p> <p>Example Code: <pre><code>/* create 3 X 3 2d array */ \nndarray_t *t = ndarray(2, (int[]){3, 3});\nprint_ndarray(t);\n\n/* create 2 X 2 X 2 3d array */ \nndarray_t *t1 = ndarray(3, (int[]){2, 2, 2});\nprint_ndarray(t1);\n</code></pre></p>"},{"location":"core-library/data-structures/ndarray/#reshapetrankshape","title":"<code>reshape(t,rank,shape)</code>","text":"<ul> <li>Parameters<ul> <li><code>t</code> : Reference to instance of ndarray that will be reshaped</li> <li><code>rank</code>: Integer value that represents amount of dimensions in value. Eg. 2d, 3d Arrays</li> <li><code>shape</code> : Array of integers that correspond to the dimensions of the value. Example values: <code>(2, 3), (6, 6)</code>. </li> </ul> </li> </ul> <p>Notes: This method requires you to provide a new rank and shape, even if the prior rank was the same. </p> <p>Example Code: <pre><code>/* create 3 X 3 2d array */ \nndarray_t *t = ndarray(2, (int[]){3, 3});\nprint_ndarray(t);\n\n/* reshape ndarray */\nreshape(t, 3, (int[]){2, 2, 2})\n</code></pre></p>"},{"location":"core-library/data-structures/ndarray/#nindext-indices","title":"<code>nindex(t, indices)</code>","text":"<ul> <li>Parameters<ul> <li><code>t</code> : Reference to instance of ndarray that will be reshaped</li> <li><code>indices</code>: Set of indices to map to one dimensional index. Length of indices is the rank of the value</li> </ul> </li> </ul> <p>Example Code: <pre><code>/* create 3 X 3 2d array */ \nndarray_t *t = ndarray(2, (int[]){3, 3});\n\n/* example nindex usage for Unit tests */\nint index = 0; \nfor(int i = 0; i &lt; 3; i++){\n    for(int j = 0; j &lt; 3; j++){\n        int test_index =  nindex(t, (int[]){i, j});\n        assert(test_index == index);    \n        index += 1;     \n    }\n}\n</code></pre></p>"},{"location":"core-library/data-structures/ndarray/#indicestindex","title":"<code>indices(t,index)</code>","text":"<ul> <li>Parameters<ul> <li><code>t</code> : Reference to instance of ndarray </li> <li><code>index</code>: Integer value that maps to index of contiguous array</li> </ul> </li> </ul> <p>Notes: This method is a helper for flattening and performing transposes/contractions</p> <p>Example Code: <pre><code>/* create 3 X 3 2d array */ \nndarray_t *t = ndarray(2, (int[]){3, 3});\nprint_ndarray(t);\n\n\n/*  set values of ndarray   */ \nint index = 0; \nfor(int i = 0; i &lt; 3; i++){\n    for(int j = 0; j &lt; 3; j++){\n        nset(t, (int[]){i, j}, index+1);\n        index += 1;     \n    }\n}\n\n/* validate indexs match */\nindex = 0;\nfor(int i = 0; i &lt; 3; i++){\n    for(int j = 0; j &lt; 3; j++){\n        int *idxs = indices(t, index); \n        assert(idxs[0] == i);\n        assert(idxs[1] == j);  \n        index += 1; \n    }\n}\n</code></pre></p>"},{"location":"core-library/data-structures/ndarray/#nidxtindices","title":"<code>nidx(t,indices)</code>","text":"<ul> <li>Parameters<ul> <li><code>t</code> : Reference to instance of ndarray </li> <li><code>indices</code>: Array of indices to map to value in ndarray</li> </ul> </li> </ul> <p>Example Code: <pre><code>/* create 3 X 3 2d array */ \nndarray_t *t = ndarray(2, (int[]){3, 3});\n\n/*  set values of ndarray   */ \nint index = 0; \nfor(int i = 0; i &lt; 3; i++){\n    for(int j = 0; j &lt; 3; j++){\n        nset(t, (int[]){i, j}, index+1);\n        index += 1;     \n    }\n}\n\ndouble value = nidx(t, (int[]){0, 0}) /* grab value at  (0, 0) */ \ndouble value1 = nidx(t, (int[]){0, 1}) /* grab value at  (0, 1) */ \n</code></pre></p>"},{"location":"core-library/data-structures/ndarray/#nsettindices-value","title":"<code>nset(t,indices, value)</code>","text":"<ul> <li>Parameters<ul> <li><code>t</code> : Reference to instance of ndarray </li> <li><code>indices</code>: Array of indices to map to value in ndarray</li> <li><code>value</code>: Value we want to set in ndarray</li> </ul> </li> </ul> <p>Example Code: <pre><code>/* create 3 X 3 2d array */ \nndarray_t *t = ndarray(2, (int[]){3, 3});\n\n/*  set values of ndarray   */ \nint index = 0; \nfor(int i = 0; i &lt; 3; i++){\n    for(int j = 0; j &lt; 3; j++){\n        nset(t, (int[]){i, j}, index+1); /* set value */\n        index += 1;     \n    }\n}\n</code></pre></p>"},{"location":"core-library/data-structures/ndarray/#save_ndarraytfilename","title":"<code>save_ndarray(t,filename)</code>","text":"<ul> <li>Parameters<ul> <li><code>t</code> : Reference to instance of ndarray </li> <li><code>filename</code>: Path to save ndarray in memory</li> </ul> </li> </ul> <p>Example Code: <pre><code>/* create 3 X 3 2d array */ \nndarray_t *t = ndarray(2, (int[]){3, 3});\n\n/*  set values of ndarray   */ \nint index = 0; \nfor(int i = 0; i &lt; 3; i++){\n    for(int j = 0; j &lt; 3; j++){\n        nset(t, (int[]){i, j}, index+1); /* set value */\n        index += 1;     \n    }\n}\n\n/* save ndarray  to path */\nsave_ndarray(t, \"path/to/file/values\")\n</code></pre></p>"},{"location":"core-library/data-structures/ndarray/#load_ndarrayfilename","title":"<code>load_ndarray(filename)</code>","text":"<ul> <li>Parameters<ul> <li><code>filename</code>: Path reference to saved ndarray</li> </ul> </li> </ul> <p>Note: The loaded ndarray will set your shape and dimensions for you, all you need is the filepath.</p> <p>Example Code: <pre><code>/* load saved ndarray */\nndarray_t *loaded = load_ndarray(\"path/to/file/values\");\n</code></pre></p>"},{"location":"core-library/data-structures/ndarray/#operations","title":"Operations","text":"Method Description <code>ndot(ndarray_t *a, ndarray_t *b)</code> Dot Product of two ndarray's <code>nadd(ndarray_t *t, ndarray_t *val)</code> Add two ndarray's <code>nsubtract(ndarray_t *t1, ndarray_t *t2)</code> Subtract two ndarray's <code>nscale_add(ndarray_t *a, ndarray_t *b)</code> Add A ndarray by vector <code>ntranspose(ndarray_t *t)</code> Tranpose of ndarray instance (rows as columns) <code>permute(ndarray_t *t, int *indice_order)</code> Contract NDArray and reorder indices"},{"location":"core-library/data-structures/ndarray/#ndota-b","title":"<code>ndot(a, b)</code>","text":"<ul> <li>Parameters<ul> <li><code>a</code>: First tensor to perform dot product</li> <li><code>b</code>: Second tensor to perform dot product</li> </ul> </li> </ul> <p>Note: Operation returns a new ndarray with the result of a and b.</p> <p>Example Code: <pre><code>/* add two 3 X 3 ndarrays */\nndarray_t *t1 = ndarray(2, (int[]){3, 3}); \nndarray_t *t2 = ndarray(2, (int[]){3, 3}); \nndarray_t *result = ndot(t1, t2);\n</code></pre></p>"},{"location":"core-library/data-structures/ndarray/#nadda-b","title":"<code>nadd(a, b)</code>","text":"<ul> <li>Parameters<ul> <li><code>a</code>: First tensor to add</li> <li><code>b</code>: Second tensor to add</li> </ul> </li> </ul> <p>Note: Operation returns a new ndarray with the result of a and b.</p> <p>Example Code: <pre><code>/* add two 3 X 3 ndarrays */\nndarray_t *t1 = ndarray(2, (int[]){3, 3}); \nndarray_t *t2 = ndarray(2, (int[]){3, 3}); \nndarray_t *result = nadd(t1, t2);\n</code></pre></p>"},{"location":"core-library/data-structures/ndarray/#nsubtractt1-t2","title":"<code>nsubtract(t1, t2)</code>","text":"<ul> <li>Parameters<ul> <li><code>t1</code>: First tensor to subtract</li> <li><code>t2</code>: Second tensor to subtract</li> </ul> </li> </ul> <p>Note: Operation returns a new ndarray with the result of a and b.</p> <p>Example Code: <pre><code>/* add two 3 X 3 ndarrays */\nndarray_t *t1 = ndarray(2, (int[]){3, 3}); \nndarray_t *t2 = ndarray(2, (int[]){3, 3}); \nndarray_t *result = nsubtract(t1, t2);\n</code></pre></p>"},{"location":"core-library/data-structures/ndarray/#nscale_adda-b","title":"<code>nscale_add(a, b)</code>","text":"<ul> <li>Parameters<ul> <li><code>a</code>: First tensor to scale add</li> <li><code>b</code>: Second tensor to scale add</li> </ul> </li> </ul> <p>Note: Operation returns a new ndarray with the result of a and b.</p> <p>Example Code: <pre><code>/* add two 3 X 3 ndarrays */\nndarray_t *t1 = ndarray(2, (int[]){3, 3}); \nndarray_t *t2 = ndarray(2, (int[]){1, 3}); /* 1  X 3 */\nndarray_t *result = nscale_add(t1, t2);\n</code></pre></p>"},{"location":"core-library/data-structures/ndarray/#ntransposet","title":"<code>ntranspose(t)</code>","text":"<ul> <li>Parameters<ul> <li><code>t</code>: Instance of ndarray to perform transpose on</li> </ul> </li> </ul> <p>Note: Operation returns a new ndarray with the result of tranpose operation.</p> <p>Example Code: <pre><code>/* add two 3 X 3 ndarrays */\nndarray_t *t1 = ndarray(2, (int[]){3, 4}); \nndarray_t *result = ntranspose(t1); /* 4 X 3 ndarray */\n</code></pre></p>"},{"location":"core-library/data-structures/ndarray/#permutet","title":"<code>permute(t)</code>","text":"<ul> <li>Parameters<ul> <li><code>t</code>: Instance of ndarray to perform permute/contraction on</li> </ul> </li> </ul> <p>Note: Operation returns a new ndarray with the result of contraction.</p> <p>Example Code: <pre><code>/* add two 3 X 3 ndarrays */\nndarray_t *t1 = ndarray(3, (int[]){3, 4, 5}); \nndarray_t *result = permute(t1, (int[]){2, 1, 0}); /* 5 X 4 X 3  ndarray */\n</code></pre></p>"},{"location":"core-library/data-structures/node/","title":"Node","text":""},{"location":"core-library/data-structures/node/#node","title":"Node","text":"<pre><code>/* Generic node */ \nstruct Node {\n    int id, weight, counter; \n    char *label;\n    struct Node* next;\n    struct Node* left; \n    struct Node* right;  \n}; \n\ntypedef struct Node node_t;\n</code></pre> <p>The Node structure is a common type used for storing data in structures and working with values in the graph library. It represents the common types needed such as integers for weight values and id's. Character types for working with text data. </p>"},{"location":"core-library/data-structures/node/#create_node","title":"create_node","text":"Parameter Name Type Description id <code>int</code> Integer id associated with node label <code>char*</code> Character label assigned to node value weight <code>int</code> Weight value to quantify relationship with other nodes <pre><code>node_t *create_node(int id, char *label, int weight); \n</code></pre>"},{"location":"core-library/data-structures/node/#print_node","title":"print_node","text":"Parameter Name Type Description node <code>node_t</code> Instance of another node pointer <pre><code>void print_node(node_t *node); \n</code></pre>"},{"location":"core-library/data-structures/node/#create_edge","title":"create_edge","text":"Parameter Name Type Description n1 <code>node_t</code> Instance of another node pointer n2 <code>node_t</code> Instance of another node pointer weight <code>int</code> Weight value to quantify relationship with other nodes <pre><code>edge_t* create_edge(node_t *n1, node_t *n2, int weight);\n</code></pre>"},{"location":"core-library/data-structures/node/#print_edge","title":"print_edge","text":"Parameter Name Type Description edge <code>edge_t</code> Instance of another edge pointer <pre><code>void print_edge(edge_t *edge); \n</code></pre>"},{"location":"core-library/data-structures/queue/","title":"Queue","text":""},{"location":"core-library/data-structures/queue/#queue","title":"Queue","text":"<p>The Queue Library is needed for keeping track of graph walks, processing results in dataframes and working with items that require FIFO/LIFO ordering.</p> <pre><code>struct Queue {\n    unsigned capacity; \n    int front_index, rear_index, item_count;\n    node_t* front, rear; \n    node_t **items; \n}; \n\ntypedef struct Queue queue_t;\n</code></pre>"},{"location":"core-library/data-structures/queue/#queue-sample","title":"Queue Sample","text":"<pre><code>/* create nodes */ \nnode_t *item1 = create_node(1, \"String Item 1\", 0);  \nnode_t *item2 = create_node(2, \"String Item 2 \", 0); \nnode_t *item3 = create_node(3, \"String Item 3 \", 0); \nnode_t *item4 = create_node(4, \"String Item 4\", 0); \nnode_t *item5 = create_node(5, \"String Item 5\", 0); \n\n/* test if queue works */ \nqueue_t *q = init_queue(count); \npush(q, item1);\npush(q, item2); \npush(q, item3); \npush(q, item4); \npush(q, item5);\nassert(q-&gt;item_count == count); \n</code></pre>"},{"location":"core-library/data-structures/queue/#init_queue","title":"init_queue","text":"Parameter Name Type Description capacity <code>unsigned</code> Capacity that queue can hold <pre><code>queue_t init_queue(unsigned *capacity); \n</code></pre>"},{"location":"core-library/data-structures/queue/#is_full","title":"is_full","text":"Parameter Name Type Description queue <code>queue_t</code> Instance of queue pointer <pre><code>int is_full(queue_t *queue); \n</code></pre>"},{"location":"core-library/data-structures/queue/#is_empty","title":"is_empty","text":"Parameter Name Type Description queue <code>queue_t</code> Instance of queue pointer <pre><code>int is_empty(queue_t *queue); \n</code></pre>"},{"location":"core-library/data-structures/queue/#front","title":"front","text":"Parameter Name Type Description queue <code>queue_t</code> Instance of queue pointer <pre><code>int front(queue_t *queue); \n</code></pre>"},{"location":"core-library/data-structures/queue/#rear","title":"rear","text":"Parameter Name Type Description queue <code>queue_t</code> Instance of queue pointer <pre><code>int rear(queue_t *queue); \n</code></pre>"},{"location":"core-library/data-structures/queue/#push","title":"push","text":"Parameter Name Type Description queue <code>queue_t</code> Instance of queue pointer item <code>node_t</code> Instance of node pointer <pre><code>void push(queue_t *queue, node_t *item); \n</code></pre>"},{"location":"core-library/data-structures/queue/#pop","title":"pop","text":"Parameter Name Type Description queue <code>queue_t</code> Instance of queue pointer <pre><code>void pop(queue_t *queue); \n</code></pre>"},{"location":"core-library/data-structures/queue/#print_queue","title":"print_queue","text":"Parameter Name Type Description queue <code>queue_t</code> Instance of queue pointer <pre><code>void print_queue(queue_t *queue); \n</code></pre>"},{"location":"core-library/data-structures/set/","title":"Set","text":""},{"location":"core-library/data-structures/set/#set","title":"Set","text":"<p>Set data structure is used for handling unique items in a list. </p> <pre><code>struct Set {\n    node_t *root;\n    queue_t *queue;  \n    bool ordered; \n    int count; \n    int *items;  \n};\n\ntypedef struct Set set_t; \n</code></pre>"},{"location":"core-library/data-structures/set/#init_set","title":"init_set","text":"Parameter Name Type Description set_order <code>bool</code> Toggle if set is ordered <pre><code>set_t *init_set(bool set_order);\n</code></pre>"},{"location":"core-library/data-structures/set/#insert_sorted","title":"insert_sorted","text":"Parameter Name Type Description s <code>set_t</code> Set instance id <code>int</code> Set ID string_value <code>char*</code> Character value weight <code>int</code> Weight value (for potential nodes) <pre><code>bool insert_sorted(set_t *s, int id, char *string_value, int weight);\n</code></pre>"},{"location":"core-library/data-structures/set/#insert_set_value_sorted","title":"insert_set_value_sorted","text":"Parameter Name Type Description root <code>node_t</code> Root in set tree item <code>node_t</code> Item to add to tree <pre><code>node_t *insert_set_value_sorted(node_t *root, node_t *item);\n</code></pre>"},{"location":"core-library/data-structures/set/#get_item_sorted","title":"get_item_sorted","text":"Parameter Name Type Description s <code>set_t</code> Instance of set key <code>char*</code> String value to search for <pre><code>int get_item_sorted(set_t *s, char *key); \n</code></pre>"},{"location":"core-library/data-structures/set/#get_items_sorted","title":"get_items_sorted","text":"Parameter Name Type Description root <code>node_t</code> Root in set tree q <code>queue_t</code> Results stored in queue <pre><code>void get_items_sorted(node_t *root, queue_t *q);\n</code></pre>"},{"location":"core-library/data-structures/set/#print_set_sorted","title":"print_set_sorted","text":"Parameter Name Type Description s <code>set_t</code> Instance of set <pre><code>void print_set_sorted(set_t *s); \n</code></pre>"},{"location":"core-library/data-structures/set/#ordered-set","title":"Ordered Set","text":"<p>Set data structure is used for handling unique items in a list in the order they're inserted.</p> <pre><code>struct OrderedSet {\n    int capacity, used, front, rear; \n    int *insert_counts;  \n    node_t **items; \n}; \n\ntypedef struct OrderedSet ordered_set_t; \n</code></pre>"},{"location":"core-library/data-structures/set/#init_array_set","title":"init_array_set","text":"Parameter Name Type Description capacity <code>int</code> Max capacity of items inserted <pre><code>ordered_set_t *init_array_set(int capacity);\n</code></pre>"},{"location":"core-library/data-structures/set/#insert_ordered","title":"insert_ordered","text":"Parameter Name Type Description s <code>ordered_set_t</code> Set instance id <code>int</code> Set ID string_value <code>char*</code> Character value weight <code>int</code> Weight value (for potential nodes) <pre><code>bool insert_ordered(ordered_set_t *s, int id, char *string_value, int weight);\n</code></pre>"},{"location":"core-library/data-structures/set/#get_insert_count","title":"get_insert_count","text":"Parameter Name Type Description s <code>ordered_set_t</code> Set instance item <code>node_t</code> Item to insert <pre><code>int get_insert_count(ordered_set_t *s, node_t *item);\n</code></pre>"},{"location":"core-library/data-structures/set/#get_value_id","title":"get_value_id","text":"Parameter Name Type Description s <code>ordered_set_t</code> Set instance id <code>int</code> Set ID <pre><code>int get_value_id(ordered_set_t *s, int id); \n</code></pre>"},{"location":"core-library/data-structures/set/#get_value_key","title":"get_value_key","text":"Parameter Name Type Description s <code>ordered_set_t</code> Set instance key <code>char</code> Character value to search <pre><code>int get_value_key(ordered_set_t *s, char *key);\n</code></pre>"},{"location":"core-library/data-structures/set/#print_items_ordered","title":"print_items_ordered","text":"Parameter Name Type Description s <code>ordered_set_t</code> Set instance <pre><code>void print_items_ordered(ordered_set_t *s);\n</code></pre>"},{"location":"releases/0.1.0/","title":"V 0.1.0","text":"<ul> <li>Support CSV graph ingestion for the following graph representations<ul> <li>Weighted/Unweighted</li> <li>Added parameters for directed or non-directed</li> </ul> </li> <li>Be able to represent graphs abstractly using the following structures<ul> <li>Adjacency List (Weighted, Unweighted, Directed, Un Directed)</li> <li>Adjacency Matrix (Weighted, Unweighted, Directed, Un Directed)</li> </ul> </li> <li>Ability to convert graphs between different structural representations<ul> <li>Adjacency Matrix \u2192 Adjacency List</li> <li>Adjacency List \u2192 Adjacency Matrix</li> </ul> </li> <li>Support feature(header) extraction of csv files.</li> <li>Generate unique character labels for each node that is created in any type of graph representation</li> <li>Fixed initial memory leaks<ul> <li>Added compilation tasks for checking memory leaks</li> </ul> </li> <li>Graphs should have these algorithms implemented.<ul> <li>Depth First Search (Searching)</li> <li>Breath First Search (Searching)</li> <li>Bellman Ford (Path finding)</li> <li>Unweighted Random Walk (Path finding)</li> <li>Degree Centrality (Centrality Algorithms)</li> <li>Strongly connected components (Community Detection)</li> </ul> </li> </ul>"},{"location":"releases/0.2.0/","title":"V 0.2.0","text":"<ul> <li>Allow relative path access for shared object file</li> <li>Add remaining test cases for matrice library and refactor</li> <li>Refactored Matrice library</li> <li>Supporting these matrice graph algorithms<ul> <li>Dijkstras (shortest path)</li> <li>Random Walk (Unweighted)</li> <li>Degree Centrality</li> </ul> </li> <li>Graph representation algorithms<ul> <li>Closeness Centrality</li> <li>Dijkstras</li> <li>Shortest Path </li> </ul> </li> <li>Fix segmentation fault for <code>csv_to_graph</code> method</li> <li>Fix memory leaks in csv and graph library</li> </ul>"},{"location":"releases/0.3.0/","title":"V 0.3.0","text":"<ul> <li>Community detection<ul> <li>Label Propagation</li> <li>Method for labeling nodes</li> </ul> </li> <li>Added Neural Network with backpropagation algorithm<ul> <li>Added module for layers, network and used matrice library</li> </ul> </li> <li>Refactor modules into separate categories<ul> <li>Module for deep learning research</li> <li>Created module for graph theory algorithms</li> <li>Added data extraction and structures module</li> </ul> </li> <li>New operations added for matrix library<ul> <li>Matrix multiplication</li> <li>Scalar value multiplication</li> <li>Raise matrix to a power </li> </ul> </li> </ul>"},{"location":"releases/0.4.0/","title":"V 0.4.0","text":"<ul> <li>Release structure has features covered for each category/module of neurograph</li> <li>Categories are separated based on<ul> <li>Data Structures</li> <li>Extraction</li> <li>Graph Library</li> <li>User interface</li> <li>Deep Learning</li> </ul> </li> </ul>"},{"location":"releases/0.4.0/#data-structures","title":"Data Structures","text":"<ul> <li>Save and load model parameters<ul> <li>Integrate these functions with neural network library</li> </ul> </li> <li>Finish all unit tests for matrice library </li> <li>Implement a unique set data structure (tree based approach)</li> </ul>"},{"location":"releases/0.4.0/#data-extraction","title":"Data Extraction","text":"<ul> <li>Redesign CSV reading and keep track of header and column counts<ul> <li>Rewrite frame to graph conversion</li> </ul> </li> <li>Create module for regular expressions<ul> <li>Single match</li> </ul> </li> <li>Data frame to graph conversion</li> </ul>"},{"location":"releases/0.4.0/#deep-learning","title":"Deep Learning","text":"<ul> <li>Create Computational graph for back propagation</li> <li>Create network with multiple hidden layers</li> </ul>"},{"location":"releases/0.4.0/#graph-library","title":"Graph Library","text":"<ul> <li>Community detection<ul> <li>Label Propagation (Iterative)</li> <li>Works with up to 2 specific label classes currently</li> </ul> </li> <li>Add general matrix structure as part of the matrix graph representation</li> <li>Triangle count</li> </ul>"},{"location":"releases/0.4.0/#user-interface","title":"User Interface","text":"<ul> <li>Expose these functionalities from the graph library<ul> <li>Searching algorithms (DFS, BFS)</li> <li>Path Finding (Shortest Path, Dijkstra, Weighted Random Walk)</li> </ul> </li> <li>Expose these functions from the queue library<ul> <li>Initialization</li> <li>Push, Pop and printing queue values</li> </ul> </li> <li>Demonstrate these in a jupyter notebook</li> </ul>"},{"location":"releases/0.4.0/#fixes-and-improvements","title":"Fixes and Improvements","text":"<ul> <li>Documented steps for all graph theory algorithms </li> <li>Cleaned up makefiles <ul> <li>Removed repetitive commands in the build process</li> <li>Making use of wildcards for header files</li> </ul> </li> <li>Ditched the csv library <ul> <li>Replaced with generic data frame library</li> </ul> </li> </ul>"},{"location":"releases/0.5.0/","title":"V 0.5.0","text":""},{"location":"releases/0.5.0/#data-structures","title":"Data Structures","text":"<ul> <li>Implement a hash map library <ul> <li>Create POC, avoid collisions at all costs</li> <li>Throw exceptions for key lookup that don't exist</li> </ul> </li> <li>Improvement and fix for the adjacency list data structure<ul> <li>Detect unused slots in the graph </li> <li>Don't allocate more nodes that aren't needed for both unweighted, weighted and directed/un-directed graphs</li> <li>Use array of pointers for node_list structure, use arrow deference for head pointer</li> </ul> </li> <li>Matrix library<ul> <li>Add method for getting columns of matrix <code>to_cols</code></li> <li>Allow option for batching a matrix and selecting a certain amount or rows</li> </ul> </li> </ul>"},{"location":"releases/0.5.0/#data-extraction","title":"Data Extraction","text":"<ul> <li>Add hash map as attribute for data frame<ul> <li>Replicate similar methods for getting cols and rows</li> </ul> </li> <li>Create a prototype of GML (graph markup language)<ul> <li>Create a regular expression for parsing this type of file format</li> <li>Create an interpreter that can serialize files</li> <li>Will not do weighted graphs in this version</li> </ul> </li> </ul>"},{"location":"releases/0.5.0/#deep-learning","title":"Deep Learning","text":"<ul> <li>Refactored computation graph to forward and backward all node types</li> <li>Added refactored computation graph representation to network module</li> </ul>"},{"location":"releases/0.5.0/#graph-library","title":"Graph Library","text":"<ul> <li>Make all random walk methods use the walk structure <ul> <li>Easier to use on the python front end</li> </ul> </li> <li>Create general graph structure that makes use of data structures<ul> <li>Include the adjacency list and matrices as inherited attributes</li> <li>Add attribute for keeping track of labeled nodes</li> </ul> </li> <li>Label propagation with multiple classes<ul> <li>Should work with more than two labels</li> <li>Discovered that graph markup serialization doesn't work here</li> </ul> </li> </ul>"},{"location":"releases/0.6.0/","title":"V 0.6.0","text":""},{"location":"releases/0.6.0/#v-060","title":"V 0.6.0","text":""},{"location":"releases/0.6.0/#data-structures","title":"Data Structures","text":"<ul> <li>Create an array based implementation for the set data structure<ul> <li>Needs to handle whether it's only looking for unique character or integer values</li> <li>Array should resize dynamically</li> </ul> </li> <li>Replace code for generating unique node ID's with set implementation</li> </ul>"},{"location":"releases/0.6.0/#graph-library","title":"Graph Library","text":"<ul> <li>Use asserts for the graph library unit tests<ul> <li>Remove repetitive if statements </li> </ul> </li> <li>Thoroughly test serialization of graph markup language files<ul> <li>Allow entries for directed and non directed graphs</li> <li>Replicate results for similar graphs in depth and breadth first search test cases</li> <li>De-Serialize in memory graphs to markup files</li> <li>Add labels and weights entry in graph markup files</li> </ul> </li> <li>Create a shared interface that can be applied for both matrix and list represented graphs<ul> <li>Shared method for adding nodes</li> <li>Printing out nodes and relationships in a graph</li> <li>Serializing and de-seralizing to markup files</li> </ul> </li> <li>Migrate all matrice graph methods to adjacency matrix structure</li> </ul>"},{"location":"releases/0.6.0/#deep-learning","title":"Deep Learning","text":"<ul> <li>Read/learn about convolutional neural networks<ul> <li>Program a convolution operation for a layer</li> </ul> </li> </ul>"},{"location":"releases/0.6.0/#remove","title":"Remove","text":"<ul> <li>Eliminate unique linked list implementation<ul> <li>Replace existing use cases with the hash set data structure</li> <li>Use hash map with out application key value</li> </ul> </li> <li>Remove item structure from queue<ul> <li>It's redundant, replace with the node structure instead</li> </ul> </li> </ul>"},{"location":"releases/0.6.0/#general-issues","title":"General Issues","text":"<ul> <li>De serializing graphs doesn't fully work as expected<ul> <li>Labels that have quotes within them won't be written to the file</li> <li>This is due to the fact that the regex extracts values between the quotes</li> <li>Need to remove quotes from label nodes and neighbors during serialization process</li> </ul> </li> </ul>"},{"location":"releases/0.7.0/","title":"V 0.7.0","text":""},{"location":"releases/0.7.0/#deep-learning","title":"Deep Learning","text":"<ul> <li>Refactored computation graph to work on operation level</li> <li>Created methods for arithmetic and basic matrix operations</li> <li>Defined general methods for operations backward and forward pass</li> <li>Created general definition of a <code>value</code> in the computation graph</li> <li>Flushed out logic for how loss functions will be added to computation graph</li> <li>Created general union abstraction around layer types for neural nets</li> <li>Implemented basic multi layer perceptron with newly refactored computation graph</li> <li>Added layer implementations for activation and linear concepts</li> <li>Refactored neural network library</li> <li>Added network methods for training and adding layers</li> </ul>"},{"location":"releases/0.7.0/#graph-library","title":"Graph Library","text":"<ul> <li>Added integration tests for GMUL file interpretation</li> </ul>"},{"location":"releases/0.7.0/#extractors","title":"Extractors","text":"<ul> <li>Added row limit for data frame structure</li> <li>Integration tests for how many rows a data frame can load</li> </ul>"},{"location":"releases/0.7.0/#pipeline","title":"Pipeline","text":"<ul> <li>Refactored pipeline workflow</li> <li>Separated build and test steps for core package</li> <li>Provided binaries in commit history</li> </ul>"},{"location":"releases/0.8.0/","title":"V 0.8.0","text":""},{"location":"releases/0.8.0/#data-structures","title":"Data Structures","text":"<ul> <li>Create array data structure with reallocation logic</li> </ul>"},{"location":"releases/0.8.0/#extractors","title":"Extractors","text":"<ul> <li>Frame to matrix conversion for training models</li> <li>Handle frame row limit counts greater than the rows in the file itself</li> <li>Handle blank values in csv file with regex</li> <li>Refactor the regex library (based on handling blank values)</li> <li>Refactor unit tests to test each method of the frame library (be more thorough)</li> </ul>"},{"location":"releases/0.8.0/#deep-learning","title":"Deep Learning","text":"<ul> <li>Add batch size training for frames in Neural Net training</li> <li>Train models using selected columns for data frame</li> <li>Save and load trained models for neural nets</li> <li>Train on row by by row basis instead of feeding the entire matrix</li> <li>Trained sample model on iris dataset</li> </ul>"},{"location":"releases/0.9.0/","title":"V 0.9.0","text":""},{"location":"releases/0.9.0/#user-interface","title":"User Interface","text":"<ul> <li>Design architecture for how python will interact with C library</li> <li>Re arrange pxds files with their respective packages for cython</li> <li>Expose data frame library and all it's functions</li> <li>Add backstage documentation site (markdown version control)</li> </ul>"},{"location":"releases/0.9.0/#data-structures","title":"Data Structures","text":"<ul> <li>Hash Maps - Open Addressing instead of linked lists</li> <li>Refactor each data structure into it's own package (Long term need)</li> <li>Delete method for array: Shift elements to empty slot</li> </ul>"},{"location":"releases/0.9.0/#extractors","title":"Extractors","text":"<ul> <li>Add open addressed hash map to data frame</li> <li>Add dropping of columns in data frame</li> <li>Add operations for adding and subtracting column values</li> <li>Separate frame and database extraction into it's own packages</li> <li>Install postgres package for databases (in pipeline as well)</li> <li>Improve makefile build sequence with pattern matching</li> </ul>"},{"location":"releases/0.9.0/#graph-library","title":"Graph Library","text":"<ul> <li>Adjust frame to graph extraction in graph library </li> <li>Remove uneeded regex values not needed in the graph library</li> </ul>"},{"location":"releases/0.9.0/#deep-learning","title":"Deep Learning","text":"<ul> <li>Create methods to save each layer</li> <li>Add a loss function map/dictionary for saving activations</li> <li>Add dictionary for mapping key value to the corresponding layer loading function</li> <li>Load and save model architectures on persistent storage</li> </ul>"},{"location":"releases/1.0.0/","title":"V 1.0.0","text":""},{"location":"releases/1.0.0/#user-interface","title":"User interface","text":"<ul> <li>Add makefile global install steps for c library </li> <li>Create C shared object file for dynamic linking</li> <li>Dynamically link C library with cython</li> <li>Added <code>libneurograph</code> directory with pxds files for python wrapper</li> <li>Added pxd files for the core library</li> <li>Added basic frame structure and operations to cython library</li> <li>Started adding some algorithms from the graph library to cython</li> <li>Set up unit test case for python library</li> </ul>"},{"location":"releases/1.0.0/#issues","title":"Issues","text":"<ul> <li>Label propagation algorithm doesn't work in cython</li> <li>Adjacency matrix can't check for null values for printing</li> </ul>"},{"location":"releases/1.01.0/","title":"V 1.01.0","text":""},{"location":"releases/1.01.0/#user-interface","title":"User Interface","text":"<ul> <li>Exposed Linear and Activation layers to cython</li> <li>Added multi layer perceptron creation with networks in cython</li> <li>Added save and load functionality for models</li> <li>Exposed all matrix library operations in pxd file</li> <li>Split core packages into their own extensions</li> <li>Decided shipping python package for final release is not worth the headache</li> </ul>"},{"location":"releases/1.01.0/#issues","title":"Issues","text":"<ul> <li>double free or corruption on batch training method</li> <li>double free or corruption on batch matrix method</li> <li>Cython does not produce the same results as the c library and has issues with stdout</li> </ul>"},{"location":"releases/1.01.0/#final-release-requirements","title":"Final Release Requirements","text":"<ul> <li>Generate backstage documentation template<ul> <li>Add to github workflow</li> <li>Start documentation on the core library</li> </ul> </li> <li>Choose a license for Github Repository</li> <li>Create guidelines for contributing</li> <li>Polish up the README, make it presentable</li> <li>Document the current state of the design in obsidian</li> <li>Document all issues for future work items in repo issues tab</li> </ul>"},{"location":"releases/releases/","title":"Releases","text":""},{"location":"releases/releases/#v-010","title":"V 0.1.0","text":"<ul> <li>Support CSV graph ingestion for the following graph representations<ul> <li>Weighted/Unweighted</li> <li>Added parameters for directed or non-directed</li> </ul> </li> <li>Be able to represent graphs abstractly using the following structures<ul> <li>Adjacency List (Weighted, Unweighted, Directed, Un Directed)</li> <li>Adjacency Matrix (Weighted, Unweighted, Directed, Un Directed)</li> </ul> </li> <li>Ability to convert graphs between different structural representations<ul> <li>Adjacency Matrix \u2192 Adjacency List</li> <li>Adjacency List \u2192 Adjacency Matrix</li> </ul> </li> <li>Support feature(header) extraction of csv files.</li> <li>Generate unique character labels for each node that is created in any type of graph representation</li> <li>Fixed initial memory leaks<ul> <li>Added compilation tasks for checking memory leaks</li> </ul> </li> <li>Graphs should have these algorithms implemented.<ul> <li>Depth First Search (Searching)</li> <li>Breath First Search (Searching)</li> <li>Bellman Ford (Path finding)</li> <li>Unweighted Random Walk (Path finding)</li> <li>Degree Centrality (Centrality Algorithms)</li> <li>Strongly connected components (Community Detection)</li> </ul> </li> </ul>"},{"location":"releases/releases/#v-020","title":"V 0.2.0","text":"<ul> <li>Allow relative path access for shared object file</li> <li>Add remaining test cases for matrice library and refactor</li> <li>Refactored Matrice library</li> <li>Supporting these matrice graph algorithms<ul> <li>Dijkstras (shortest path)</li> <li>Random Walk (Unweighted)</li> <li>Degree Centrality</li> </ul> </li> <li>Graph representation algorithms<ul> <li>Closeness Centrality</li> <li>Dijkstras</li> <li>Shortest Path </li> </ul> </li> <li>Fix segmentation fault for <code>csv_to_graph</code> method</li> <li>Fix memory leaks in csv and graph library</li> </ul>"},{"location":"releases/releases/#v-030","title":"V 0.3.0","text":"<ul> <li>Community detection<ul> <li>Label Propagation</li> <li>Method for labeling nodes</li> </ul> </li> <li>Added Neural Network with backpropagation algorithm<ul> <li>Added module for layers, network and used matrice library</li> </ul> </li> <li>Refactor modules into separate categories<ul> <li>Module for deep learning research</li> <li>Created module for graph theory algorithms</li> <li>Added data extraction and structures module</li> </ul> </li> <li>New operations added for matrix library<ul> <li>Matrix multiplication</li> <li>Scalar value multiplication</li> <li>Raise matrix to a power </li> </ul> </li> </ul>"},{"location":"releases/releases/#v-040","title":"V 0.4.0","text":"<ul> <li>Release structure has features covered for each category/module of neurograph</li> <li>Categories are separated based on<ul> <li>Data Structures</li> <li>Extraction</li> <li>Graph Library</li> <li>User interface</li> <li>Deep Learning</li> </ul> </li> </ul>"},{"location":"releases/releases/#data-structures","title":"Data Structures","text":"<ul> <li>Save and load model parameters<ul> <li>Integrate these functions with neural network library</li> </ul> </li> <li>Finish all unit tests for matrice library </li> <li>Implement a unique set data structure (tree based approach)</li> </ul>"},{"location":"releases/releases/#data-extraction","title":"Data Extraction","text":"<ul> <li>Redesign CSV reading and keep track of header and column counts<ul> <li>Rewrite frame to graph conversion</li> </ul> </li> <li>Create module for regular expressions<ul> <li>Single match</li> </ul> </li> <li>Data frame to graph conversion</li> </ul>"},{"location":"releases/releases/#deep-learning","title":"Deep Learning","text":"<ul> <li>Create Computational graph for back propagation</li> <li>Create network with multiple hidden layers</li> </ul>"},{"location":"releases/releases/#graph-library","title":"Graph Library","text":"<ul> <li>Community detection<ul> <li>Label Propagation (Iterative)</li> <li>Works with up to 2 specific label classes currently</li> </ul> </li> <li>Add general matrix structure as part of the matrix graph representation</li> <li>Triangle count</li> </ul>"},{"location":"releases/releases/#user-interface","title":"User Interface","text":"<ul> <li>Expose these functionalities from the graph library<ul> <li>Searching algorithms (DFS, BFS)</li> <li>Path Finding (Shortest Path, Dijkstra, Weighted Random Walk)</li> </ul> </li> <li>Expose these functions from the queue library<ul> <li>Initialization</li> <li>Push, Pop and printing queue values</li> </ul> </li> <li>Demonstrate these in a jupyter notebook</li> </ul>"},{"location":"releases/releases/#fixes-and-improvements","title":"Fixes and Improvements","text":"<ul> <li>Documented steps for all graph theory algorithms </li> <li>Cleaned up makefiles <ul> <li>Removed repetitive commands in the build process</li> <li>Making use of wildcards for header files</li> </ul> </li> <li>Ditched the csv library <ul> <li>Replaced with generic data frame library</li> </ul> </li> </ul>"},{"location":"releases/releases/#v-050","title":"V 0.5.0","text":""},{"location":"releases/releases/#data-structures_1","title":"Data Structures","text":"<ul> <li>Implement a hash map library <ul> <li>Create POC, avoid collisions at all costs</li> <li>Throw exceptions for key lookup that don't exist</li> </ul> </li> <li>Improvement and fix for the adjacency list data structure<ul> <li>Detect unused slots in the graph </li> <li>Don't allocate more nodes that aren't needed for both unweighted, weighted and directed/un-directed graphs</li> <li>Use array of pointers for node_list structure, use arrow deference for head pointer</li> </ul> </li> <li>Matrix library<ul> <li>Add method for getting columns of matrix <code>to_cols</code></li> <li>Allow option for batching a matrix and selecting a certain amount or rows</li> </ul> </li> </ul>"},{"location":"releases/releases/#data-extraction_1","title":"Data Extraction","text":"<ul> <li>Add hash map as attribute for data frame<ul> <li>Replicate similar methods for getting cols and rows</li> </ul> </li> <li>Create a prototype of GML (graph markup language)<ul> <li>Create a regular expression for parsing this type of file format</li> <li>Create an interpreter that can serialize files</li> <li>Will not do weighted graphs in this version</li> </ul> </li> </ul>"},{"location":"releases/releases/#deep-learning_1","title":"Deep Learning","text":"<ul> <li>Refactored computation graph to forward and backward all node types</li> <li>Added refactored computation graph representation to network module</li> </ul>"},{"location":"releases/releases/#graph-library_1","title":"Graph Library","text":"<ul> <li>Make all random walk methods use the walk structure <ul> <li>Easier to use on the python front end</li> </ul> </li> <li>Create general graph structure that makes use of data structures<ul> <li>Include the adjacency list and matrices as inherited attributes</li> <li>Add attribute for keeping track of labeled nodes</li> </ul> </li> <li>Label propagation with multiple classes<ul> <li>Should work with more than two labels</li> <li>Discovered that graph markup serialization doesn't work here</li> </ul> </li> </ul>"},{"location":"releases/releases/#v-060","title":"V 0.6.0","text":""},{"location":"releases/releases/#data-structures_2","title":"Data Structures","text":"<ul> <li>Create an array based implementation for the set data structure<ul> <li>Needs to handle whether it's only looking for unique character or integer values</li> <li>Array should resize dynamically</li> </ul> </li> <li>Replace code for generating unique node ID's with set implementation</li> </ul>"},{"location":"releases/releases/#graph-library_2","title":"Graph Library","text":"<ul> <li>Use asserts for the graph library unit tests<ul> <li>Remove repetitive if statements </li> </ul> </li> <li>Thoroughly test serialization of graph markup language files<ul> <li>Allow entries for directed and non directed graphs</li> <li>Replicate results for similar graphs in depth and breadth first search test cases</li> <li>De-Serialize in memory graphs to markup files</li> <li>Add labels and weights entry in graph markup files</li> </ul> </li> <li>Create a shared interface that can be applied for both matrix and list represented graphs<ul> <li>Shared method for adding nodes</li> <li>Printing out nodes and relationships in a graph</li> <li>Serializing and de-seralizing to markup files</li> </ul> </li> <li>Migrate all matrice graph methods to adjacency matrix structure</li> </ul>"},{"location":"releases/releases/#deep-learning_2","title":"Deep Learning","text":"<ul> <li>Read/learn about convolutional neural networks<ul> <li>Program a convolution operation for a layer</li> </ul> </li> </ul>"},{"location":"releases/releases/#remove","title":"Remove","text":"<ul> <li>Eliminate unique linked list implementation<ul> <li>Replace existing use cases with the hash set data structure</li> <li>Use hash map with out application key value</li> </ul> </li> <li>Remove item structure from queue<ul> <li>It's redundant, replace with the node structure instead</li> </ul> </li> </ul>"},{"location":"releases/releases/#general-issues","title":"General Issues","text":"<ul> <li>De serializing graphs doesn't fully work as expected<ul> <li>Labels that have quotes within them won't be written to the file</li> <li>This is due to the fact that the regex extracts values between the quotes</li> <li>Need to remove quotes from label nodes and neighbors during serialization process</li> </ul> </li> </ul>"},{"location":"releases/releases/#v-070","title":"V 0.7.0","text":""},{"location":"releases/releases/#deep-learning_3","title":"Deep Learning","text":"<ul> <li>Refactored computation graph to work on operation level</li> <li>Created methods for arithmetic and basic matrix operations</li> <li>Defined general methods for operations backward and forward pass</li> <li>Created general definition of a <code>value</code> in the computation graph</li> <li>Flushed out logic for how loss functions will be added to computation graph</li> <li>Created general union abstraction around layer types for neural nets</li> <li>Implemented basic multi layer perceptron with newly refactored computation graph</li> <li>Added layer implementations for activation and linear concepts</li> <li>Refactored neural network library</li> <li>Added network methods for training and adding layers</li> </ul>"},{"location":"releases/releases/#graph-library_3","title":"Graph Library","text":"<ul> <li>Added integration tests for GMUL file interpretation</li> </ul>"},{"location":"releases/releases/#extractors","title":"Extractors","text":"<ul> <li>Added row limit for data frame structure</li> <li>Integration tests for how many rows a data frame can load</li> </ul>"},{"location":"releases/releases/#pipeline","title":"Pipeline","text":"<ul> <li>Refactored pipeline workflow</li> <li>Separated build and test steps for core package</li> <li>Provided binaries in commit history</li> </ul>"},{"location":"releases/releases/#v-080","title":"V 0.8.0","text":""},{"location":"releases/releases/#data-structures_3","title":"Data Structures","text":"<ul> <li>Create array data structure with reallocation logic</li> </ul>"},{"location":"releases/releases/#extractors_1","title":"Extractors","text":"<ul> <li>Frame to matrix conversion for training models</li> <li>Handle frame row limit counts greater than the rows in the file itself</li> <li>Handle blank values in csv file with regex</li> <li>Refactor the regex library (based on handling blank values)</li> <li>Refactor unit tests to test each method of the frame library (be more thorough)</li> </ul>"},{"location":"releases/releases/#deep-learning_4","title":"Deep Learning","text":"<ul> <li>Add batch size training for frames in Neural Net training</li> <li>Train models using selected columns for data frame</li> <li>Save and load trained models for neural nets</li> <li>Train on row by by row basis instead of feeding the entire matrix</li> <li>Trained sample model on iris dataset</li> </ul>"}]}